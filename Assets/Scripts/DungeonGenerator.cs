using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;

public class DungeonGenerator : MonoBehaviour
{
    [Header("Settings")]
    public RoomDatabase roomDatabase;
    [Range(7, 10)]
    public int mainPathLength = 7;
    [Range(1, 5)]
    public int maxArmLength = 3;
    [Range(0, 100)]
    public int armGenerationChance = 70;
    [Range(0, 100)]
    public int deadEndPreferenceForArms = 80;

    [Header("Debug")]
    public bool debugGeneration = false;
    public bool generateOnStart = true;

    [Header("Player Setup")]
    public GameObject player; // Referenz zum Spieler

    // Generierte Level-Daten
    [HideInInspector]
    public List<RoomData> generatedRooms = new List<RoomData>();
    private Dictionary<int, GameObject> spawnedRooms = new Dictionary<int, GameObject>();
    private int nextRoomId = 0;

    private void Start()
    {
        // Prüfe, ob automatische Generierung vom StartMenu angefordert wurde
        if (PlayerPrefs.GetInt("AutoGenerateDungeon", 0) == 1)
        {
            // Reset des Flags
            PlayerPrefs.SetInt("AutoGenerateDungeon", 0);
            PlayerPrefs.Save();

            // Generiere Dungeon und spawne Startraum
            GenerateDungeonAndSpawnStart();
        }
        else if (generateOnStart)
        {
            GenerateDungeon();
        }
    }

    public void GenerateDungeonAndSpawnStart()
    {
        // Generiere den Dungeon
        GenerateDungeon();

        // Spawne Raum 0 (Startraum) sofort
        if (generatedRooms.Count > 0)
        {
            GameObject startRoom = SpawnRoom(0);

            // Positioniere den Spieler im Startraum
            if (startRoom != null && player != null)
            {
                PositionPlayerInRoom(startRoom, 0);
            }
            else if (player == null)
            {
                // Versuche den Spieler automatisch zu finden
                GameObject foundPlayer = GameObject.FindGameObjectWithTag("Player");
                if (foundPlayer != null)
                {
                    player = foundPlayer;
                    PositionPlayerInRoom(startRoom, 0);
                }
                else
                {
                    Debug.LogWarning("Spieler nicht gefunden! Bitte Player-Referenz im DungeonGenerator setzen oder Player-Tag verwenden.");
                }
            }
        }
    }

    private void PositionPlayerInRoom(GameObject roomObject, int roomNumber)
    {
        Room roomComponent = roomObject.GetComponent<Room>();
        if (roomComponent != null)
        {
            // Versuche einen Spawnpunkt zu finden
            Transform spawnPoint = roomComponent.GetSpawnPointForDirection(Direction.South); // Standard-Spawnpunkt

            if (spawnPoint != null)
            {
                player.transform.position = spawnPoint.position;
                player.transform.rotation = spawnPoint.rotation;
            }
            else
            {
                // Fallback: Setze Spieler in die Mitte des Raums
                player.transform.position = roomObject.transform.position + Vector3.up * 1f;
            }

            if (debugGeneration)
            {
                Debug.Log($"Spieler in Raum {roomNumber} positioniert.");
            }
        }
        else
        {
            // Fallback: Setze Spieler in die Mitte des Raums
            player.transform.position = roomObject.transform.position + Vector3.up * 1f;
            Debug.LogWarning($"Room-Komponente in Raum {roomNumber} nicht gefunden. Spieler wurde in die Mitte des Raums gesetzt.");
        }
    }

    public void GenerateDungeon()
    {
        // Zurücksetzen des Generators
        CleanupGeneratedRooms();
        nextRoomId = 0;
        generatedRooms.Clear();

        if (roomDatabase == null)
        {
            Debug.LogError("Keine RoomDatabase zugewiesen!");
            return;
        }

        // Generierungslogik starten
        GenerateMainPath();

        if (debugGeneration)
        {
            Debug.Log($"Dungeon generiert mit {generatedRooms.Count} Räumen");
            DebugPrintDungeonLayout();
        }
    }

    private void GenerateMainPath()
    {
        // 1. Startpunkt finden
        var startRooms = roomDatabase.GetRoomsWithTag("start");
        if (startRooms.Count == 0)
        {
            Debug.LogError("Kein Startraum mit Tag 'start' gefunden!");
            return;
        }

        // Startraum auswählen
        RoomData startRoom = startRooms[Random.Range(0, startRooms.Count)];
        RoomData currentRoomData = CreateRoomInstance(startRoom);

        // Startpunkt ist jetzt der aktuelle Raum
        int currentRoomId = currentRoomData.roomNumber;

        // 2. Hauptpfad generieren
        List<int> mainPathRooms = new List<int> { currentRoomId };
        Direction nextDirection = GetRandomAvailableDirection(currentRoomData);

        for (int i = 0; i < mainPathLength - 1; i++)
        {
            Direction requiredEntrance = GetOppositeDirection(nextDirection);

            // Get compatible rooms (now automatically excludes start/end/fallback rooms)
            var compatibleRooms = GetRoomsWithEntrance(requiredEntrance);

            if (i < mainPathLength - 2)
            {
                compatibleRooms = compatibleRooms.Where(r =>
                    CountExits(r) >= 2).ToList();

                if (compatibleRooms.Count == 0)
                {
                    Debug.LogWarning("Keine Räume mit mindestens 2 Ausgängen gefunden! Verwende normale Räume.");
                    compatibleRooms = GetRoomsWithEntrance(requiredEntrance);
                }
            }

            if (compatibleRooms.Count == 0)
            {
                Debug.LogError("Keine kompatiblen Räume für Hauptpfad gefunden!");
                break;
            }

            RoomData nextRoomTemplate = compatibleRooms[Random.Range(0, compatibleRooms.Count)];
            RoomData nextRoom = CreateRoomInstance(nextRoomTemplate);

            ConnectRooms(currentRoomData, nextRoom, nextDirection);

            // WICHTIG: Arme vom vorherigen Raum generieren, aber NICHT vom aktuellen
            // da der aktuelle Raum noch weitere Verbindungen bekommen könnte
            GenerateArmsFromRoom(currentRoomData, mainPathRooms);

            currentRoomData = nextRoom;
            currentRoomId = currentRoomData.roomNumber;
            mainPathRooms.Add(currentRoomId);

            List<Direction> availableDirections = GetAvailableDirections(currentRoomData);
            availableDirections.Remove(GetOppositeDirection(nextDirection));

            if (availableDirections.Count == 0)
            {
                Debug.LogWarning("No more directions available!");
                break;
            }

            nextDirection = availableDirections[Random.Range(0, availableDirections.Count)];
        }

        // 3. Endraum GARANTIERT anfügen
        EnsureEndRoom(currentRoomData, mainPathRooms);
    }

    private void EnsureEndRoom(RoomData currentRoom, List<int> mainPathRooms)
    {
        // Endräume finden
        var endRooms = roomDatabase.GetRoomsWithTag("end");
        if (endRooms.Count == 0)
        {
            Debug.LogError("Kein Endraum mit Tag 'end' gefunden!");
            return;
        }

        // Verfügbare Richtungen vom aktuellen Raum
        List<Direction> availableDirections = GetAvailableDirections(currentRoom);

        if (availableDirections.Count == 0)
        {
            Debug.LogError("Aktueller Raum hat keine verfügbaren Ausgänge für Endraum!");
            return;
        }

        // Versuche einen direkten Endraum zu finden
        RoomData endRoom = null;
        Direction connectionDirection = Direction.North;

        foreach (Direction direction in availableDirections)
        {
            Direction requiredEndEntrance = GetOppositeDirection(direction);
            var compatibleEndRooms = GetCompatibleEndRooms(endRooms, requiredEndEntrance);

            if (compatibleEndRooms.Count > 0)
            {
                endRoom = CreateRoomInstance(compatibleEndRooms[Random.Range(0, compatibleEndRooms.Count)]);
                connectionDirection = direction;
                break;
            }
        }

        // Wenn ein direkter Endraum möglich ist
        if (endRoom != null)
        {
            // Direkter Endraum verbinden
            ConnectRooms(currentRoom, endRoom, connectionDirection);

            // Arme vom letzten Hauptpfad-Raum generieren (NACH der Endraum-Verbindung)
            GenerateArmsFromRoom(currentRoom, mainPathRooms);
        }
        else
        {
            // Wenn kein direkter Endraum möglich ist, verwende Fallback-Raum
            if (debugGeneration)
            {
                Debug.Log("Kein direkter Endraum möglich - verwende Fallback-Raum");
            }

            var fallbackRooms = roomDatabase.GetRoomsWithTag("fallback");
            if (fallbackRooms.Count == 0)
            {
                Debug.LogError("Keine Fallback-Räume gefunden! Kann Endraum nicht garantieren.");
                return;
            }

            // Fallback-Raum finden der passt
            RoomData fallbackRoom = null;
            Direction fallbackDirection = Direction.North;

            foreach (Direction direction in availableDirections)
            {
                Direction requiredFallbackEntrance = GetOppositeDirection(direction);
                var compatibleFallbackRooms = GetCompatibleFallbackRooms(fallbackRooms, requiredFallbackEntrance);

                if (compatibleFallbackRooms.Count > 0)
                {
                    fallbackRoom = CreateRoomInstance(compatibleFallbackRooms[Random.Range(0, compatibleFallbackRooms.Count)]);
                    fallbackDirection = direction;
                    break;
                }
            }

            if (fallbackRoom == null)
            {
                Debug.LogError("Kein passender Fallback-Raum gefunden!");
                return;
            }

            // Fallback-Raum verbinden
            ConnectRooms(currentRoom, fallbackRoom, fallbackDirection);

            // Endraum am Fallback-Raum anfügen (Fallback-Räume haben immer Nordausgang)
            var finalEndRooms = GetCompatibleEndRooms(endRooms, Direction.South);
            if (finalEndRooms.Count > 0)
            {
                endRoom = CreateRoomInstance(finalEndRooms[Random.Range(0, finalEndRooms.Count)]);
                ConnectRooms(fallbackRoom, endRoom, Direction.North);
            }
            else
            {
                Debug.LogError("Kein Endraum mit Südeingang für Fallback-Raum gefunden!");
            }

            // Arme vom letzten Hauptpfad-Raum generieren (NACH allen Verbindungen)
            GenerateArmsFromRoom(currentRoom, mainPathRooms);
        }
    }

    private List<RoomData> GetCompatibleEndRooms(List<RoomData> endRooms, Direction requiredEntrance)
    {
        return endRooms.Where(r =>
            (requiredEntrance == Direction.North && r.hasNorthExit) ||
            (requiredEntrance == Direction.East && r.hasEastExit) ||
            (requiredEntrance == Direction.South && r.hasSouthExit) ||
            (requiredEntrance == Direction.West && r.hasWestExit)).ToList();
    }

    private List<RoomData> GetCompatibleFallbackRooms(List<RoomData> fallbackRooms, Direction requiredEntrance)
    {
        return fallbackRooms.Where(r =>
            r.hasNorthExit && // Fallback-Räume müssen immer Nordausgang haben
            ((requiredEntrance == Direction.East && r.hasEastExit) ||
             (requiredEntrance == Direction.South && r.hasSouthExit) ||
             (requiredEntrance == Direction.West && r.hasWestExit))).ToList();
    }

    private void GenerateArmsFromRoom(RoomData room, List<int> mainPathRooms)
    {
        // Nur die tatsächlich freien Richtungen verwenden (keine bereits verbundenen)
        List<Direction> freeDirections = GetAvailableDirections(room);

        foreach (Direction direction in freeDirections)
        {
            if (Random.Range(0, 100) < armGenerationChance)
            {
                GenerateArm(room, direction, mainPathRooms);
            }
        }
    }

    private void GenerateArm(RoomData startRoom, Direction direction, List<int> mainPathRooms)
    {
        int armLength = Random.Range(1, maxArmLength + 1);
        RoomData currentRoom = startRoom;
        Direction currentDirection = direction;

        for (int i = 0; i < armLength; i++)
        {
            // Die entgegengesetzte Richtung wird für den nächsten Raum benötigt
            Direction requiredEntrance = GetOppositeDirection(currentDirection);

            // Liste von kompatiblen Räumen erstellen (excludes start/end/fallback automatically)
            List<RoomData> compatibleRooms = GetRoomsWithEntrance(requiredEntrance);

            // Am Ende des Arms bevorzugt Sackgassen verwenden
            if (i == armLength - 1 || Random.Range(0, 100) < deadEndPreferenceForArms)
            {
                var deadEndRooms = compatibleRooms.Where(r => r.roomTag == "deadend").ToList();
                if (deadEndRooms.Count > 0)
                {
                    compatibleRooms = deadEndRooms;
                }
            }

            if (compatibleRooms.Count == 0)
            {
                Debug.LogWarning($"Keine passenden Räume für Arm in Richtung {currentDirection} gefunden!");
                break;
            }

            // Zufälligen Raum auswählen
            RoomData nextRoomTemplate = compatibleRooms[Random.Range(0, compatibleRooms.Count)];
            RoomData nextRoom = CreateRoomInstance(nextRoomTemplate);

            // Verbinde aktuellen Raum mit nächstem Raum
            ConnectRooms(currentRoom, nextRoom, currentDirection);

            // Wenn es ein Sackgassenraum ist oder der letzte im Arm, dann hier aufhören
            if (nextRoom.roomTag == "deadend" || i == armLength - 1)
            {
                break;
            }

            // Gehe zum nächsten Raum
            currentRoom = nextRoom;

            // Bestimme neue Richtung (nicht zurück)
            List<Direction> availableDirections = GetAvailableDirections(currentRoom);
            availableDirections.Remove(GetOppositeDirection(currentDirection)); // Nicht zurückgehen

            if (availableDirections.Count == 0)
            {
                break; // Keine weiteren Richtungen verfügbar
            }

            currentDirection = availableDirections[Random.Range(0, availableDirections.Count)];
        }
    }

    private RoomData CreateRoomInstance(RoomData template)
    {
        // Erstelle eine Kopie der RoomData mit einer eindeutigen ID
        RoomData newRoom = new RoomData
        {
            roomName = template.roomName,
            roomPrefab = template.roomPrefab,
            hasNorthExit = template.hasNorthExit,
            hasEastExit = template.hasEastExit,
            hasSouthExit = template.hasSouthExit,
            hasWestExit = template.hasWestExit,
            roomTag = template.roomTag,
            roomNumber = nextRoomId++,
            northRoomNumber = -1,
            eastRoomNumber = -1,
            southRoomNumber = -1,
            westRoomNumber = -1
        };

        generatedRooms.Add(newRoom);
        return newRoom;
    }

    private void ConnectRooms(RoomData room1, RoomData room2, Direction direction)
    {
        // Verbinde die beiden Räume in der angegebenen Richtung
        switch (direction)
        {
            case Direction.North:
                room1.northRoomNumber = room2.roomNumber;
                room2.southRoomNumber = room1.roomNumber;
                break;
            case Direction.East:
                room1.eastRoomNumber = room2.roomNumber;
                room2.westRoomNumber = room1.roomNumber;
                break;
            case Direction.South:
                room1.southRoomNumber = room2.roomNumber;
                room2.northRoomNumber = room1.roomNumber;
                break;
            case Direction.West:
                room1.westRoomNumber = room2.roomNumber;
                room2.eastRoomNumber = room1.roomNumber;
                break;
        }

        if (debugGeneration)
        {
            Debug.Log($"Verbinde Raum {room1.roomNumber} ({room1.roomName}) mit Raum {room2.roomNumber} ({room2.roomName}) in Richtung {direction}");
        }
    }

    private List<RoomData> GetRoomsWithEntrance(Direction direction)
    {
        List<RoomData> rooms;

        // Get rooms with the required entrance direction
        switch (direction)
        {
            case Direction.North:
                rooms = roomDatabase.GetRoomsWithNorthEntrance();
                break;
            case Direction.East:
                rooms = roomDatabase.GetRoomsWithEastEntrance();
                break;
            case Direction.South:
                rooms = roomDatabase.GetRoomsWithSouthEntrance();
                break;
            case Direction.West:
                rooms = roomDatabase.GetRoomsWithWestEntrance();
                break;
            default:
                return new List<RoomData>();
        }

        // Filter out rooms with "start", "end", and "fallback" tags for normal connections
        return rooms.Where(r => r.roomTag != "start" && r.roomTag != "end" && r.roomTag != "fallback").ToList();
    }

    private List<Direction> GetAvailableDirections(RoomData room)
    {
        List<Direction> directions = new List<Direction>();

        if (room.hasNorthExit && room.northRoomNumber == -1)
            directions.Add(Direction.North);
        if (room.hasEastExit && room.eastRoomNumber == -1)
            directions.Add(Direction.East);
        if (room.hasSouthExit && room.southRoomNumber == -1)
            directions.Add(Direction.South);
        if (room.hasWestExit && room.westRoomNumber == -1)
            directions.Add(Direction.West);

        return directions;
    }

    private Direction GetRandomAvailableDirection(RoomData room)
    {
        List<Direction> directions = GetAvailableDirections(room);

        if (directions.Count == 0)
        {
            Debug.LogError($"Raum {room.roomNumber} hat keine verfügbaren Richtungen!");
            return Direction.North; // Fallback
        }

        return directions[Random.Range(0, directions.Count)];
    }

    private Direction GetOppositeDirection(Direction direction)
    {
        switch (direction)
        {
            case Direction.North: return Direction.South;
            case Direction.East: return Direction.West;
            case Direction.South: return Direction.North;
            case Direction.West: return Direction.East;
            default: return Direction.North;
        }
    }

    private int CountExits(RoomData room)
    {
        int count = 0;
        if (room.hasNorthExit) count++;
        if (room.hasEastExit) count++;
        if (room.hasSouthExit) count++;
        if (room.hasWestExit) count++;
        return count;
    }

    private void CleanupGeneratedRooms()
    {
        // Lösche alle zuvor generierten Räume
        foreach (var roomEntry in spawnedRooms)
        {
            if (roomEntry.Value != null)
            {
                if (Application.isPlaying)
                {
                    Destroy(roomEntry.Value);
                }
                else
                {
                    DestroyImmediate(roomEntry.Value);
                }
            }
        }

        spawnedRooms.Clear();
    }

    private void DebugPrintDungeonLayout()
    {
        // Debug-Ausgabe der Struktur
        string debugOutput = "Dungeon Layout:\n";

        foreach (var room in generatedRooms)
        {
            debugOutput += $"Room {room.roomNumber} ({room.roomName}, Tag: {room.roomTag}):\n";
            debugOutput += $"  North: {room.northRoomNumber}\n";
            debugOutput += $"  East: {room.eastRoomNumber}\n";
            debugOutput += $"  South: {room.southRoomNumber}\n";
            debugOutput += $"  West: {room.westRoomNumber}\n";
        }

        Debug.Log(debugOutput);
    }

    // Öffentliche Methode zum Spawnen eines Raums
    public GameObject SpawnRoom(int roomNumber)
    {
        if (roomNumber < 0 || roomNumber >= generatedRooms.Count)
        {
            Debug.LogError($"Raumnummer {roomNumber} existiert nicht!");
            return null;
        }

        // Wenn der Raum bereits gespawnt wurde, verwende diesen
        if (spawnedRooms.ContainsKey(roomNumber) && spawnedRooms[roomNumber] != null)
        {
            return spawnedRooms[roomNumber];
        }

        RoomData roomData = generatedRooms[roomNumber];

        if (roomData.roomPrefab == null)
        {
            Debug.LogError($"Raum {roomNumber} hat kein Prefab!");
            return null;
        }

        // Instantiate Room
        GameObject roomObject = Instantiate(roomData.roomPrefab, Vector3.zero, Quaternion.identity);
        Room roomComponent = roomObject.GetComponent<Room>();

        if (roomComponent != null)
        {
            // Hier können wir dem Room die korrekte RoomData zuweisen
            roomComponent.data = roomData;
            roomComponent.SetupExits();
        }

        spawnedRooms[roomNumber] = roomObject;
        return roomObject;
    }

    // Löscht den aktuellen Raum und spawnt den angegebenen neuen Raum
    public GameObject TransitionToRoom(int currentRoomNumber, int nextRoomNumber, Direction direction)
    {
        // Aktuellen Raum entfernen
        if (spawnedRooms.ContainsKey(currentRoomNumber))
        {
            if (spawnedRooms[currentRoomNumber] != null)
            {
                Destroy(spawnedRooms[currentRoomNumber]);
            }
            spawnedRooms.Remove(currentRoomNumber);
        }

        // Neuen Raum spawnen
        GameObject newRoom = SpawnRoom(nextRoomNumber);

        // Wenn der Spieler umgesetzt werden muss, können wir hier den Spawnpunkt basierend auf der Richtung bekommen
        if (newRoom != null)
        {
            Room roomComponent = newRoom.GetComponent<Room>();
            if (roomComponent != null)
            {
                // Hier könnte der Spieler zum entsprechenden Spawnpunkt teleportiert werden
                Transform spawnPoint = roomComponent.GetSpawnPointForDirection(GetOppositeDirection(direction));

                // Spieler positionieren wenn verfügbar
                if (player != null && spawnPoint != null)
                {
                    player.transform.position = spawnPoint.position;
                    player.transform.rotation = spawnPoint.rotation;
                }
            }
        }

        return newRoom;
    }
}

#if UNITY_EDITOR
[CustomEditor(typeof(DungeonGenerator))]
public class DungeonGeneratorEditor : Editor
{
    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();

        DungeonGenerator generator = (DungeonGenerator)target;

        EditorGUILayout.Space();

        if (GUILayout.Button("Generate Dungeon"))
        {
            generator.GenerateDungeon();
        }

        if (GUILayout.Button("Generate Dungeon and Spawn Start"))
        {
            generator.GenerateDungeonAndSpawnStart();
        }

        EditorGUILayout.Space();
        EditorGUILayout.LabelField("Generierte Räume", EditorStyles.boldLabel);

        if (generator.generatedRooms.Count == 0)
        {
            EditorGUILayout.HelpBox("Noch keine Räume generiert.", MessageType.Info);
            return;
        }

        foreach (var room in generator.generatedRooms)
        {
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);

            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField($"Raum {room.roomNumber}: {room.roomName}", EditorStyles.boldLabel);
            EditorGUILayout.LabelField($"Tag: {room.roomTag}");
            EditorGUILayout.EndHorizontal();

            EditorGUI.indentLevel++;

            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("North:", GUILayout.Width(60));
            EditorGUILayout.LabelField(room.northRoomNumber != -1 ? room.northRoomNumber.ToString() : "None");
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("East:", GUILayout.Width(60));
            EditorGUILayout.LabelField(room.eastRoomNumber != -1 ? room.eastRoomNumber.ToString() : "None");
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("South:", GUILayout.Width(60));
            EditorGUILayout.LabelField(room.southRoomNumber != -1 ? room.southRoomNumber.ToString() : "None");
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("West:", GUILayout.Width(60));
            EditorGUILayout.LabelField(room.westRoomNumber != -1 ? room.westRoomNumber.ToString() : "None");
            EditorGUILayout.EndHorizontal();

            EditorGUI.indentLevel--;

            EditorGUILayout.EndVertical();

            // Spawn-Button für jeden Raum
            if (GUILayout.Button($"Spawn Raum {room.roomNumber}"))
            {
                generator.SpawnRoom(room.roomNumber);
            }
        }
    }
}
#endif